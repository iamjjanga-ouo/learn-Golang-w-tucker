## 포인터

### 포인터 변수 선언

```go
var a int
var p *int
p = &a
*p = 20 // 값 대입
```

- 포인터 변수값을 초기화하지 않으면 기본값은 `nil`

### 포인터를 왜 쓰나?

- 변수 대입이나, 함수 인수 전달은 항상 값을 복사하기 때문에 많은 메모리 공간을 사용하는 문제,
- 큰 메모리 공간을 복사할 때 발생하는 성능 문제
- 다른 공간으로 복사되기 때문에 변경 사항에 대한 적용이 되지 않는 문제도 있음.

[포인터를 쓰지 않는 예제 코드](./no_pointer/main.go)

- `ChangeData()` 함수 호출 시 data 변숫값이 모두 복사 -> 구조체 크기(int(8) + [200]int(1600) = 1608)만큼 복사

[포인터를 쓰는 예제 코드](./yes_pointer/main.go)

- `ChangeData(&data)`로 `data`의 메모리 주소를 인수로 전달. 8바이트만 전달.
- `arg`는 포인터 변수이기 때문에 `(*arg).value = 999`를 사용해야하지만, Go언어에서는 `arg.value = 999`로도 동작.

### Data 구조체를 생성해 포인터 변수 초기화하기

- 구조체를 별도로 생성하지 않고, 곧바로 포인터 변수에 구조체를 생성해 주소를 초기값을 대입할 수 있음.
- 기존 방식
  ```go
  var data Data
  var p *Data = &data
  ```
- 구조체를 생성해 초기화하는 방식
  ```go
  var p *Data = &Data{}
  ```

### 인스턴스

- 인스턴스 : 메모리에 할당된 데이터의 실체
  ```go
  var data Data       // 인스턴스
  var p *Data = &data
  ```
- 인스턴스는 데이터의 실체
  - ex) 구조체 포인터를 함수 매개변수로 받는다 = 구조체 인스턴스로 입력을 받음

### `new()` 내장함수

```go
p1 := &Data{}     // &을 사용한 초기화
var p2 = new(Data)// new()를 사용하는 초기화
```

- `p1 := &Data{3,4}` 사용자 초기화 가능
- `new(Data)`는 내부 필드값을 원하는 값으로 초기화 x

### 인스턴스 언제 사라지는지?

- GC(Garbage Collector)이 일정 간격으로 메모리에서 쓸모없어진 데이터를 청소

### 스택 메모리와 힙 메모리

- 스택 메모리는 함수 내부에서만 사용가능한 영역, 함수외부에서는 외부로 공개되는 메모리 공간은 힙 메모리 영역으로 할당
- C/C++ : `malloc()`, Java : Class Type으로, Go 언어 : Escape Analysis(탈출 검사)

[Go 언어의 탈출 검사 예제 코드](./heap_memory/main.go)

- 탈출 검사를 통해 `u` 변수의 인스턴스가 함수 외부로 공개되는 것을 분석해서 `u`를 스택이 아닌 **힙** 메모리에 할당
- Go 언어에서 스택 메모리는 계속 증가되는 동적 메모리 풀. (C/C++과 비교해 메모리 효율성 높고, 재귀 호출때문에 스택 메모리가 고갈될 문제 발생 x)
