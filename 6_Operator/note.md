## 06 : 연산자
- Go에서 모든 연사자의 각 항의 타입은 항상 같아야함. (시프트 연산 제외)
- 예를 들어, 정수 + 실수 or 정수 - 실수는 `허용 X`, 타입변환을 해서 연산해야함.

### 산술연산자
- 다른 언어와 비슷해서 스킵

### 비트 연산자
- `&^(비트 클리어 연산자)`
  - 특정 비트를 0으로 바꾸는 연산자. 우변값에 해당하는 비트를 클리어하는 연산자
  - `^`를 먼저 수행하고 나서 `&`를 수행
    ```
    10&^2

    1. ^연산을 수행
    2  -> 0000 0010
    ^2 -> 1111 1110

    2. &연산을 수행
    10 -> 0000 1010
    ^2 -> 1111 1101
    10&^2 -> 0000 1000
    ```

### 시프트 연산자
- `<<`(왼쪽 시프트)
  - 오른쪽 피연산자 값만큼 전체 비트를 왼쪽으로 밀어냄.
  - 비트가 이동되어 빈자리는 `0`으로 채움.
  - 자리수를 벗어난 비트는 버려짐.
- `>>`(오른쪽 시프트)
  - 비트값을 오른쪽으로 밈
  - 오른쪽 피연산자수는 반드시 *양의 정수*
  - 왼쪽에 추가되는 비트들은 최상위 비트값과 같은 비트값

### 비교 연산자
- 다른 언어와 비슷
- 자바스크립트와 달리 `===` Stict Equal 체크하는 연산자가 없음. 아니 애초에 `==` 자체가 값과 타입을 다 비교해서 필요없을 듯.
- 주의할 부분 (*부호가 있는 정수를 사용할 때 발생하는 Overflow와 UnderFlow*)
  - 정수 오버플로우
    - 정수가 정수 타입의 범위를 벗어난 경우 값이 비정상으로 변화하는 현상
    - 따라서, x가 정수 타입일 경우 `x < x+1`을 항상 만족(true)하지 못함.
    - [Over-Under flow 예제 코드](integer_flow.go)
  - float 비교 연산
    - 실수 끼리 `==` 연산에서 예기치 않는 경우가 있음
    - float64 표현 방식으로 생긴 오차
    - [실수 == 예제코드](float_equal_unexpected.go)

### 실수 오차
- 컴퓨터의 지수부와 소수부는 10진수 기준이 아닌 *2진수*의 기준으로 되어있음.
- 예를들어,
  ```
  0.375 = 1 x 2^-2 + 1 x 2^-3
  0.376는...? 2진수로 어려움.
  ```
- 따라서 최대한 가깝게 표현한 값 0.3759999...로 표현
- `0.1 + 0.2 == 0.3`이 `false`인 이유가 있음.
- 문제를 해결하는 방법
  - [작은 오차 무시하기](dismiss_small.go)
  - 더 나은 방법 : [1비트 차이만큼 비교](nextafter.go)
    - math 패키지의 `Nextafter()` 함수를 사용
      ```Go
      func Nextafter(x, y float64) (r float64)
      ```
      - float64 2개를 받아 float64 1개로 반환
      - x에서 y를 향해 1비트만 조정한 값을 반환
  - [float 정확도 big 패키지](big.go)

## 논리 연산자
- 다른 언어랑 비슷

## 대입 연산자
- 좌변 대입에 생략식을 사용할 수 없음
  ```Go
  var a int
  var b int
  a = b = 10 // ERROR

  a = 10  // OK
  b = 10

  a,b = 10, 10 // OK
  ```
- Swap
  ```go
  a, b = b, a // OK
  ```

- 증감연산자
  - `++`, `--`, `+=`, `-=` 다 지원
  - 단, 전위 연산 `X`, 후위 증감연산자만 지원
  - 그 외의 오류,
    ```Go
    b = a++ // ERROR
    ```

